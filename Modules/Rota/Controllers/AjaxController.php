<?php
/*
 * FLOCKR
 * Multi-Purpose Church Administration Suite
 * http://github.com/potofcoffee/flockr
 * http://flockr.org
 *
 * Copyright (c) 2016+ Christoph Fischer (chris@toph.de)
 *
 * Parts copyright 2003-2015 Renzo Lauper, renzo@churchtool.org
 * FlockR is a fork from the kOOL project (www.churchtool.org). kOOL is available
 * under the terms of the GNU General Public License (see below).
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


namespace Peregrinus\Flockr\Rota\Controllers;


use Peregrinus\Flockr\Core\AbstractController;
use Peregrinus\Flockr\Core\Debugger;
use Peregrinus\Flockr\Core\Services\AccessService;
use Peregrinus\Flockr\Core\Services\HookService;
use Peregrinus\Flockr\Core\Services\SessionService;
use Peregrinus\Flockr\Core\Services\SettingsService;
use Peregrinus\Flockr\Core\Settings\DoubleSelectSetting;
use Peregrinus\Flockr\Core\Settings\SelectSetting;
use Peregrinus\Flockr\Rota\Domain\Repository\EventRepository;
use Peregrinus\Flockr\Rota\Domain\Repository\GroupRepository;
use Peregrinus\Flockr\Rota\Domain\Repository\PeopleRepository;
use Peregrinus\Flockr\Rota\Domain\Repository\ScheduleRepository;
use Peregrinus\Flockr\Rota\Domain\Repository\TeamRepository;
use Peregrinus\Flockr\Rota\Utility\TimeSpanUtility;

class AjaxController extends AbstractController
{
    /**
     * @var EventRepository
     */
    protected $eventRepository = null;

    /**
     * @var TeamRepository
     */
    protected $teamRepository = null;

    /**
     * @var GroupRepository
     */
    protected $groupRepository = null;

    /**
     * @var PeopleRepository
     */
    protected $peopleRepository = null;

    /**
     * @var ScheduleRepository
     */
    protected $scheduleRepository = null;

    /**
     * @var AccessService
     */
    protected $accessService = null;

    /**
     * @var SessionService
     */
    protected $sessionService = null;

    /**
     * Initialize controller
     */
    public function initializeController()
    {
        parent::initializeController(); // TODO: Change the autogenerated stub
        $this->eventRepository = new EventRepository();
        $this->teamRepository = new TeamRepository();
        $this->groupRepository = new GroupRepository();
        $this->peopleRepository = new PeopleRepository();
        $this->scheduleRepository = new ScheduleRepository();
        $this->accessService = AccessService::getInstance();
        $this->sessionService = SessionService::getInstance();
    }

    /**
     * @action plan
     * @return bool
     */
    public function planAction()
    {
        $this->initDefaults();

        // get time values from request?
        $timeStart = $this->getFromRequestOrSession('rota_timestart');
        $timeSpan = $this->getFromRequestOrSession('rota_timespan');

        // change time?
        if ($this->request->hasArgument('changeTime')) {
            $delta = $this->request->getArgument('changeTime');
            if (in_array(substr($delta, 0, 1), ['+', '-'])) {
                $timeStart = date('Y-m-d', strtotime($timeStart . ' ' . str_replace(['d', 'w', 'm'], [' days', ' weeks', ' months'], $delta)));
            } else {
                $timeStart = $delta;
            }
            $this->sessionService->setArgument('rota_timestart', $timeStart);
        }

        // timespan select
        $availableTimespans = [];
        foreach (['1d', '1w', '2w', '1m', '2m', '3m', '6m', '12m'] as $timespanOption) {
            $availableTimespans[$timespanOption] = getLL('rota_timespan_' . $timespanOption);
        }
        $this->view->assign('availableTimeSpans', $availableTimespans);
        $this->view->assign('timeStart', $timeStart);
        $this->view->assign('timeSpan', $timeSpan);

        $teams = $this->teamRepository->getFromSession();


        $events = $this->eventRepository->findPlanableEvents(
            $teams,
            0,
            $this->sessionService->getArgument('rota_egs'),
            $timeStart,
            $timeSpan
        );

        // exports
        $exports = HookService::getInstance()->applyFilters('rota_exports', []);

        $this->view->assign('teams', $teams);
        $this->view->assign('events', $events);
        $this->view->assign('title', TimeSpanUtility::formatAsString($timeStart, $timeSpan));
        $this->view->assign('exports', $exports);
    }


    /**
     * Set defaults on timespan and timestart
     * @return void
     */
    protected function initDefaults()
    {
        if (!$this->sessionService->hasArgument('rota_timespan')) {
            $this->sessionService->setArgument('rota_timespan', '1m');
        }
        if (!$this->sessionService->hasArgument('rota_timestart')) {
            $this->sessionService->setArgument('rota_timestart', date('Y-m-d'));
        }
    }

    /**
     * Display the schedule dialog for a given event and team
     * @action scheduleEvent
     */
    public function eventScheduleAction()
    {
        if (!$this->request->hasArgument('event')) return false;
        if (!$this->request->hasArgument('team')) return false;

        $event = $this->eventRepository->findOneByUid($this->request->getArgument('event'));
        $team = $this->teamRepository->findOneByUid($this->request->getArgument('team'));

        if (!($this->accessService->hasAccess('rota', 'MAX', 3)
            || $this->accessService->hasAccess('rota', $team['id'], 3))
        ) return false;

        // get all groups for this team
        $groups = $this->groupRepository->findMultipleWithChildren($team['group_id']);

        // get full group paths for list
        $showGroups = [];
        $groupIds = [];
        foreach ($groups as $group) {
            $groupIds[] = $group['id'];
        }
        $groupIds = array_unique($groupIds);
        foreach ($groupIds as $group) {
            $showGroups[] = $this->groupRepository->getFullGroupName($group);
        }

        // get the necessary role, if set
        if (SettingsService::getInstance()->getGlobalSetting('rota_showroles')) {
            $role = SettingsService::getInstance()->getGlobalSetting('rota_teamrole');
            $role = $role ? ':r' . $role : '';
        } else {
            $role = '';
        }

        // find all people in the respective groups
        $where = [];
        foreach ($groups as $group) {
            $where[] .= "`groups` REGEXP 'g" . $group['id'] . ($role != '' ? '(g0-9:)*' . $role : '') . "'";
        }
        $people = $this->peopleRepository->find(count($where) ? 'WHERE ' . join(' OR ', $where) : '');

        // find who is already schedulled
        $schedule = $this->scheduleRepository->findOneByEventAndTeam($event['id'], $team['id']);

        // prepare a doubleSelect
        $available = [];
        foreach ($people as $person) {
            $available[$person['id']] = $person['vorname'] . ' ' . $person['nachname'];
        }
        $scheduledPeople = [];
        $textEntries = [];
        foreach ($schedule['schedule']['members'] as $member) {
            if ($member['type'] == 'person') {
                $scheduledPeople[$member['person']['id']] = $member['person']['vorname'] . ' ' . $member['person']['nachname'];
            } else {
                $textEntries[] = $member['text'];
            }
        }
        $peopleSelect = new DoubleSelectSetting('scheduledPeople', 'Personen zum Dienst einteilen', 0, $available, $scheduledPeople);
        $peopleSelect->setValue(join(',', array_keys($scheduledPeople)));

        $this->view->assign('peopleSelect', $peopleSelect);
        $this->view->assign('textEntries', join("\r\n", $textEntries));
        $this->view->assign('groups', join(', ', $showGroups));


    }

    public function saveEventScheduleAction()
    {

        $eventId = $this->request->getArgument('event');
        $teamId = $this->request->getArgument('team');

        // basic access check
        if (!($this->accessService->hasAccess('rota', 'MAX', 3)
            || $this->accessService->hasAccess('rota', $teamId, 3))
        ) {
            $this->forward('plan');
        }

        // find existing schedule
        $schedule = $this->scheduleRepository->findOneByEventAndTeam($eventId, $teamId);

        // do not updated locked schedules
        if ($schedule && ($schedule['status'] != 1)) $this->forward('plan');

        // create new schedule
        $peopleIds = explode(',', $this->request->getArgument('people'));
        $textEntries = explode("\n", str_replace(',', '//', str_replace("\r", '', $this->request->getArgument('textEntries'))));

        $entries = [];
        if (count($peopleIds)) $entries = $peopleIds;
        if (count($textEntries)) $entries = array_merge($entries, $textEntries);
        foreach ($entries as $key => $entry) {
            if (!trim($entry)) unset($entries[$key]);
        }

        $newSchedule = [
            'event_id' => $eventId,
            'team_id' => $teamId,
            'schedule' => join(',', $entries),
            'status' => 1, // unlocked
        ];


        if ($schedule) {
            if ($newSchedule['schedule'] !== '') {
                $this->scheduleRepository->update($newSchedule);
            } else {
                $this->scheduleRepository->delete($newSchedule);
            }
        } else {
            if ($newSchedule['schedule'] !== '') {
                $this->scheduleRepository->add($newSchedule);
            }
        }


        $this->forward('plan');
    }

    /**
     * Lock an event, so schedules can't be changed any more
     * This is accomplished by setting status to 2 on all schedules for this event
     * @action lockEvent
     */
    public function lockEventAction() {
        if (!$this->request->hasArgument('event')) $this->forward('plan');
        if (!($this->accessService->hasAccess('rota', 'MAX', 3))) $this->forward('plan');

        $eventId = $this->request->getArgument('event');
        $this->eventRepository->setEventStatus($eventId, 2);

        $this->forward('plan');
    }

    /**
     * Unlock an event, so schedules can be changed
     * This is accomplished by setting status to 1 on all schedules for this event
     * @action unlockEvent
     */
    public function unlockEventAction() {
        if (!$this->accessService->hasAccess('rota', 'MAX', 3)) $this->forward('plan');
        if (!$this->request->hasArgument('event')) $this->forward('plan');
        if (!($this->accessService->hasAccess('rota', 'MAX', 3))) $this->forward('plan');

        $eventId = $this->request->getArgument('event');
        $this->eventRepository->setEventStatus($eventId, 1);

        $this->forward('plan');
    }


    /**
     * Lock all currently displayed events, so schedules can't be changed any more
     * This is accomplished by setting status to 2 on all schedules for this event
     * @action lockAll
     */
    public function lockAllAction() {
        $timeStart = $this->getFromRequestOrSession('rota_timestart');
        $timeSpan = $this->getFromRequestOrSession('rota_timespan');
        $teams = $this->teamRepository->getFromSession();
        $eventGroups = $this->sessionService->getArgument('rota_egs');
        foreach ($this->eventRepository->getDisplayedEvents($timeStart, $timeSpan, $teams, $eventGroups) as $event) {
            $this->eventRepository->setEventStatus($event['id'], 2);
        }
        $this->forward('plan');
    }

    /**
     * Unlock all currently displayed events, so schedules can be changed
     * This is accomplished by setting status to 1 on all schedules for this event
     * @action unlockAll
     */
    public function unlockAllAction() {
        if (!$this->accessService->hasAccess('rota', 'MAX', 3)) $this->forward('plan');
        $timeStart = $this->getFromRequestOrSession('rota_timestart');
        $timeSpan = $this->getFromRequestOrSession('rota_timespan');
        $teams = $this->teamRepository->getFromSession();
        $eventGroups = $this->sessionService->getArgument('rota_egs');
        foreach ($this->eventRepository->getDisplayedEvents($timeStart, $timeSpan, $teams, $eventGroups) as $event) {
            $this->eventRepository->setEventStatus($event['id'], 1);
        }
        $this->forward('plan');
    }

    /**
     * Toggle display on/off for a specific team
     * @action toggleTeam
     */
    public function toggleTeamAction() {
        if (!$this->request->hasArgument('team')) $this->forward('plan');
        if (!$this->request->hasArgument('on')) $this->forward('plan');
        if (!$this->accessService->hasAccess('rota', 'MAX', 1)) $this->forward('plan');

        $teamId = $this->request->getArgument('team');
        $on = $this->request->getArgument('on') == 'true' ? true : false;

        $displayedTeams = $this->sessionService->getArgument('rota_teams');
        if ($on == true) {
            if (!in_array($teamId, $displayedTeams)) $displayedTeams[] = $teamId;
        } else {
            if (in_array($teamId, $displayedTeams)) unset($displayedTeams[array_search($teamId, $displayedTeams)]);
        }

        $this->sessionService->setArgument('rota_teams', $displayedTeams);

        $this->forward('plan');
    }

    /**
     * Toggle display on/off for a specific event group
     * @action toggleEventGroup
     */
    public function toggleEventGroupAction() {
        if (!$this->request->hasArgument('eventgroup')) $this->forward('plan');
        if (!$this->request->hasArgument('on')) $this->forward('plan');
        if (!$this->accessService->hasAccess('rota', 'MAX', 1)) $this->forward('plan');

        $eventGroupId = $this->request->getArgument('eventgroup');
        $on = $this->request->getArgument('on') == 'true' ? true : false;

        $displayedEventGroups = $this->sessionService->getArgument('rota_egs');
        if ($on == true) {
            if (!in_array($eventGroupId, $displayedEventGroups)) $displayedEventGroups[] = $eventGroupId;
        } else {
            if (in_array($eventGroupId, $displayedEventGroups)) unset($displayedEventGroups[array_search($eventGroupId, $displayedEventGroups)]);
        }
        $this->sessionService->setArgument('rota_egs', $displayedEventGroups);

        $this->forward('plan');
    }


}